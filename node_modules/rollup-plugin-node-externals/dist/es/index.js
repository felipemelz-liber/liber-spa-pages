import builtinModules from 'builtin-modules';
import { dirname, isAbsolute, relative } from 'path';
import { promises } from 'fs';
import findUp from 'find-up';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function isInDirectory(parent, child) {
    const relativePath = relative(parent, child);
    return !relativePath.startsWith('..') && !isAbsolute(relativePath);
}
function findPackagePaths() {
    return __asyncGenerator(this, arguments, function* findPackagePaths_1() {
        const gitDirectoryPath = yield __await(findUp('.git', { type: 'directory' }));
        const gitRootPath = gitDirectoryPath === undefined
            ? undefined
            : dirname(gitDirectoryPath);
        function isInGitDirectory(path) {
            return gitRootPath === undefined || isInDirectory(gitRootPath, path);
        }
        let cwd = process.cwd();
        let packagePath;
        while ((packagePath = yield __await(findUp('package.json', { type: 'file', cwd }))) &&
            isInGitDirectory(packagePath)) {
            yield yield __await(packagePath);
            cwd = dirname(dirname(packagePath));
        }
    });
}
function findDependencies({ packagePaths, keys, warnings }) {
    var packagePaths_1, packagePaths_1_1;
    var e_1, _a;
    var _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const dependencies = new Set();
        try {
            for (packagePaths_1 = __asyncValues(packagePaths); packagePaths_1_1 = yield packagePaths_1.next(), !packagePaths_1_1.done;) {
                const packagePath = packagePaths_1_1.value;
                try {
                    const pkg = (_b = JSON.parse((yield promises.readFile(packagePath)).toString())) !== null && _b !== void 0 ? _b : {};
                    for (const key of keys) {
                        const dependenciesToVersions = (_c = pkg[key]) !== null && _c !== void 0 ? _c : {};
                        for (const dependency of Object.keys(dependenciesToVersions)) {
                            dependencies.add(dependency);
                        }
                    }
                }
                catch (_d) {
                    warnings.push(`Couldn't process '${packagePath}'. Make sure it is a valid JSON or use the 'packagePath' option`);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (packagePaths_1_1 && !packagePaths_1_1.done && (_a = packagePaths_1.return)) yield _a.call(packagePaths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Array.from(dependencies);
    });
}

function externals(options = {}) {
    const warnings = [];
    const opts = Object.assign({ packagePath: [], builtins: true, deps: false, devDeps: true, peerDeps: true, optDeps: true, include: [], exclude: [], except: [] }, options);
    const [include, exclude, except] = ['include', 'exclude', 'except'].map(option => new Array()
        .concat(opts[option])
        .map((entry, index) => {
        if (entry instanceof RegExp) {
            return entry;
        }
        else if (typeof entry === 'string') {
            return new RegExp('^' + entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$');
        }
        else {
            if (!!entry) {
                warnings.push(`Ignoring wrong entry type #${index} in '${option}' option: '${entry}'`);
            }
            return /(?=no)match/;
        }
    }));
    if (except.length > 0) {
        warnings.push("'except' option is deprecated, please use include/exclude instead");
        exclude.push(...except);
    }
    const f = dep => !exclude.some(rx => rx.test(dep));
    const builtins = (opts.builtins ? builtinModules : []).filter(f);
    let packagePaths = [].concat(opts.packagePath);
    const externals = [];
    return {
        name: 'node-externals',
        resolveId(source, importer) {
            return importer && !/\0/.test(source) && externals.some(deps => deps.test(source)) ? false : null;
        },
        buildStart() {
            return __awaiter(this, void 0, void 0, function* () {
                const dependencies = (yield findDependencies({
                    packagePaths: packagePaths.length > 0 ? packagePaths : findPackagePaths(),
                    keys: [
                        opts.deps && 'dependencies',
                        opts.devDeps && 'devDependencies',
                        opts.peerDeps && 'peerDependencies',
                        opts.optDeps && 'optionalDependencies'
                    ].filter(Boolean),
                    warnings
                })).filter(f);
                let msg;
                while (msg = warnings.shift()) {
                    this.warn(msg);
                }
                if (builtins.length > 0) {
                    externals.push(new RegExp('^(?:' + builtins.join('|') + ')(\/.+)?$'));
                }
                if (dependencies.length > 0) {
                    externals.push(new RegExp('^(?:' + dependencies.join('|') + ')(\/.+)?$'));
                }
                if (include.length > 0) {
                    externals.push(...include);
                }
            });
        }
    };
}

export default externals;
//# sourceMappingURL=index.js.map
